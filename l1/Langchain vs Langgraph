
# 🚀 LangChain vs LangGraph — Complete Notes + Example

---

## 🔹 What is LangChain? 🛣️
- Open-source library to build LLM apps.
- Works with **chains**:
```

Prompt → Model → Output

```
- Great for:
- Chatbots 🤖
- Summarization ✂️
- Simple RAG 🔍
- ❌ Limitations:
- Stateless (no built-in memory of workflow progress)
- Loops 🔁 and conditionals ❓ are hard
- Event-driven triggers ⏳ not supported
- State must be handled manually `{}`

---

## 🔹 Why LangGraph Exists 🛤️
LangGraph was built because:
1. Workflows can be **non-linear** (branches, loops, retries).
2. Need **state management** 📦 → state flows through the workflow.
3. **Fault tolerance** 🔄 → resume from last checkpoint.
4. **Human-in-the-loop** 👨‍💼 approvals.
5. **Event-driven triggers** ⏳ (wait, then continue).

---

## 🔹 What is LangGraph?
- Framework on top of LangChain
- Represents workflows as **graphs**
- ⬤ Node = workflow step
- → Edge = transition
- 📦 State = shared mutable data
- Supports:
- Conditionals ❓
- Loops 🔁
- Retries 🔄
- Event-driven waits ⏳
- Human approvals 👨‍💼

---

## 🔹 LangChain vs LangGraph (Comparison)

| Feature               | LangChain 🛣️ | LangGraph 🛤️ |
|-----------------------|--------------|---------------|
| Workflow type         | Linear ➡️ | Graph ↔️↕️ |
| State management      | Manual 📝 | Built-in 📦 |
| Loops                 | Hard 🔁 | Natural 🔄 |
| Conditionals          | Manual ❓ | Native ✔️❌ |
| Human approval        | Difficult 🙅 | Supported 👨‍💼 |
| Fault tolerance       | Limited ⚠️ | Strong ✅ |
| Use case examples     | Chatbot 🤖, RAG 🔍 | Hiring process 👨‍💼, Multi-agent 🤝, Finance 💰 |

---

## 🔹 Automated Hiring Workflow (LangGraph Style)

```

📥 Start (Hiring Request)
|
v
⬤ Create JD (LLM 🤖)
|
v
⬤ Check JD Approval ❓
\|-------------------|
✅ Yes                 ❌ No
\|                      |
v                      v
⬤ Post JD             🔁 Loop back
|
v
⏳ Wait 7 Days
|
v
⬤ Monitor Applications
|
v

| 📊 Enough Applications? ❓                      |
| ---------------------------------------------- |
| ✅ Yes                  ❌ No                    |
|                                                |
| v                       v                      |
| ⬤ Shortlist Candidates   🔁 Modify JD + Repost |

```
  |
  v
```

⏳ Wait 48 Hours
|
v
⬤ Resume Parsing Tool (Score > 20)
|
v

| ⬤ Send Offer Letter ❓                    |
| ---------------------------------------- |
| ✅ Yes                  ❌ No              |
|                                          |
| v                       v                |
| ⬤ Schedule Interview     📧 Regret Email |

```
  |
  v
```

⬤ Conduct Interview
|
v

| 📌 Selected? ❓                           |
| ---------------------------------------- |
| ✅ Yes                  ❌ No              |
|                                          |
| v                       v                |
| ⬤ Send Offer Letter      📧 Regret Email |

```
  |
  v
```

| ⬤ Offer Accepted? ❓                          |
| -------------------------------------------- |
| ✅ Yes                  ❌ No → 🔄 Renegotiate |
|                                              |
| v                                            |
| 🚀 Onboarding                                |
|                                              |
| v                                            |
| 🏁 End                                       |

````

---

## 🔹 LangGraph Example (Python)

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

# ---- Define State ----
class HiringState(TypedDict):
    jd: str
    jd_approved: bool
    applications: int
    shortlisted: list
    offer_sent: bool
    offer_accepted: bool

# ---- Define Node Functions ----
def create_jd(state: HiringState):
    jd_text = "Backend Engineer JD (generated by LLM)"
    state["jd"] = jd_text
    return state

def check_approval(state: HiringState):
    state["jd_approved"] = True  # Simulated auto-approval
    return state

def post_jd(state: HiringState):
    print("✅ JD Posted:", state["jd"])
    return state

def monitor_apps(state: HiringState):
    state["applications"] = 25  # Simulated applications
    return state

def shortlist(state: HiringState):
    state["shortlisted"] = ["Alice", "Bob"]
    return state

def send_offer(state: HiringState):
    state["offer_sent"] = True
    state["offer_accepted"] = True
    return state

def onboarding(state: HiringState):
    print("🚀 Onboarding started for", state["shortlisted"][0])
    return state

# ---- Build Graph ----
workflow = StateGraph(HiringState)

workflow.add_node("create_jd", create_jd)
workflow.add_node("check_approval", check_approval)
workflow.add_node("post_jd", post_jd)
workflow.add_node("monitor_apps", monitor_apps)
workflow.add_node("shortlist", shortlist)
workflow.add_node("send_offer", send_offer)
workflow.add_node("onboarding", onboarding)

# Define edges
workflow.add_edge("create_jd", "check_approval")
workflow.add_conditional_edges(
    "check_approval",
    lambda state: "post_jd" if state["jd_approved"] else "create_jd",
    {"post_jd": "post_jd", "create_jd": "create_jd"}
)
workflow.add_edge("post_jd", "monitor_apps")
workflow.add_edge("monitor_apps", "shortlist")
workflow.add_edge("shortlist", "send_offer")
workflow.add_edge("send_offer", "onboarding")
workflow.add_edge("onboarding", END)

# ---- Compile and Run ----
app = workflow.compile()
final_state = app.invoke(HiringState(
    jd="",
    jd_approved=False,
    applications=0,
    shortlisted=[],
    offer_sent=False,
    offer_accepted=False
))
print("🏁 Final State:", final_state)
````

---

# ✅ Key Takeaways

* **LangChain** = linear, stateless, simple 🛣️
* **LangGraph** = graph-based, stateful, resilient 🛤️
* Use LangChain for **chatbots & RAG**
* Use LangGraph for **complex workflows (like hiring)**

---

```

---

```
